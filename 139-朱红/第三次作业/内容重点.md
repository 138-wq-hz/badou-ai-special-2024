# （插值方法1：最邻近插值）
# 1.插值方法2：双线性插值
## 1.1 定义
单线性插值：

$$ y = \frac { x _ { 1 } - x } { x _ { 1 } - x _ { 0 } } y _ { 0 } + \frac { x - x _ { 0 } } { x _ { 1 } - x _ { 0 } } y _ { 1 }$$

（1）在x方向做插值：

$$ f ( R _ { 1 } ) = f ( x , y _ { 1 } ) \approx \frac { x _ { 2 } - x } { x _ { 2 } - x _ { 1 } } f ( Q _ { 1 1 } ) + \frac { x - x _ { 1 } } { x _ { 2 } - x _ { 1 } } f ( Q _ { 2 1 } ) , $$

$$ f ( R _ { 2 } ) = f ( x , y _ { 2 } ) \approx \frac { x _ { 2 } - x } { x _ { 2 } - x _ { 1 } } f ( Q _ { 1 2 } ) +\frac { x - x _ { 1 } } { x _ { 2 } - x _ { 1 } } f ( Q _ { 2 2 } ) .$$

（2）在y方向做插值：

$$ f ( x , y ) \approx \frac { y _ { 2 } - y } { y _ { 2 } - y _ { 1 } } f ( R _ { 1 } ) + \frac { y - y _ { 1 } } { y _ { 2 } - y _ { 1 } } f ( R _ { 2 } )$$

（3）综合上述式子：

$$ f ( x , y ) \approx \frac { y _ { 2 } - y } { y _ { 2 } - y _ { 1 } } ( \frac { x _ { 2 } - x } { x _ { 2 } - x _ { 1 } } f ( Q _ { 1 1 } ) + \frac { x - x _ { 1 } } { x _ { 2 } - x _ { 1 } } f ( Q _ { 2 1 } ) ) + \frac { y - y _ { 1 } } { y _ { 2 } - y _ { 1 } } \left( \frac { x _ { 2 } - x } { x _ { 2 } - x _ { 1 } } f ( Q _ { 1 2 } ) + \frac { x - x _ { 1 } } { x _ { 2 } - x _ { 1 } } f ( Q _ { 2 2 } ) \right)$$

由于双线性插值只会用相邻的4个点，因此上述公式的分母都是1

$$ f ( x , y ) \approx ( { y _ { 2 } - y } ) [  ( { x _ { 2 } - x } ) f ( Q _ { 1 1 } ) + ( { x - x _ { 1 } } ) f ( Q _ { 2 1 } ) ] + ( { y - y _ { 1 } } ) \left[ ( { x _ { 2 } - x } ) f ( Q _ { 1 2 } ) + ( { x - x _ { 1 } } ) f ( Q _ { 2 2 } ) ] \right)$$

（4）补充：使两个图像的几何中心重合：

$$ S r c X + 0 . 5 = ( d s t X + 0 . 5 ) \ast ( s r c W i d t h / d s t W i d t h )$$

$$ S r c Y + 0 . 5 = ( d s t Y + 0 . 5 ) \ast ( s r c H e i g h t / d s t H e i g h t )$$

## 1.2 代码

```python
def bilinear_interpolation(img,out_dim):
    src_h, src_w, channel = img.shape
    dst_h, dst_w = out_dim[1], out_dim[0]
    print ("src_h, src_w = ", src_h, src_w)
    print ("dst_h, dst_w = ", dst_h, dst_w)
    if src_h == dst_h and src_w == dst_w:
        return img.copy()
    dst_img = np.zeros((dst_h,dst_w,3),dtype=np.uint8)
    scale_x, scale_y = float(src_w) / dst_w, float(src_h) / dst_h
    for i in range(channel):
        for dst_y in range(dst_h):
            for dst_x in range(dst_w):
 
                # find the origin x and y coordinates of dst image x and y
                # use geometric center symmetry
                # if use direct way, src_x = dst_x * scale_x
                src_x = (dst_x + 0.5) * scale_x-0.5
                src_y = (dst_y + 0.5) * scale_y-0.5
 
                # find the coordinates of the points which will be used to compute the interpolation
                src_x0 = int(np.floor(src_x))     #np.floor()返回不大于输入参数的最大整数。（向下取整）
                src_x1 = min(src_x0 + 1 ,src_w - 1)
                src_y0 = int(np.floor(src_y))
                src_y1 = min(src_y0 + 1, src_h - 1)
 
                # calculate the interpolation
                temp0 = (src_x1 - src_x) * img[src_y0,src_x0,i] + (src_x - src_x0) * img[src_y0,src_x1,i]
                temp1 = (src_x1 - src_x) * img[src_y1,src_x0,i] + (src_x - src_x0) * img[src_y1,src_x1,i]
                dst_img[dst_y,dst_x,i] = int((src_y1 - src_y) * temp0 + (src_y - src_y0) * temp1)
 
    return dst_img
```


# 2.直方图均衡化
## 2.1 定义&作用
原有定义：将原图像的直方图通过变换函数变为均匀的直方图，再按均匀直方图修改原图像，以获得灰度分布均匀的新图像（使直方图大致平和的方法）

自己理解：使图像的每个灰度级的像素个数大致均匀的方法

作用：图像增强
## 2.2 步骤

（1）依次扫描灰度图像的每一个像素，计算出图像的灰度直方图H

（2）计算灰度直方图的累加直方图

对于输入图像的任意一个像素p，p∈[0,255]，总能在输出图像里有对应像素q，q∈[0,255]使得下式成立：

（**输入与输出的像素总量相等**）

$$ \sum _ { k = 0 } ^ { p } h i s t _ { i n p u t } ( k ) = \sum _ { k = 0 } ^ { q } h i s t _ { o u t } ( k )$$

其中，输出图像的每个灰度级的个数为：

$$ h i s t _ { o u t } ( k ) \approx \frac { H * W } { 2 5 6 } , k \in \left[ 0 , 2 5 5 \right]$$

（3）根据累加直方图和直方图均衡化原理得到输入与输出之间的映射关系

$$ \sum _ { k = 0 } ^ { p } h i s t _ { i n p u t } ( k ) \approx ( q + 1 ) \frac { H * W } { 2 5 6 }$$

（4）根据映射关系得到结果

$$ q \approx \sum _ { k = 0 } ^ { p } \frac { h i s t _ { i n p u t } ( k ) } { H \ast W } \ast 2 5 6 - 1$$

（5）举例

![image](https://github.com/Jadeuniq/badou-ai-special-2024/assets/144694703/4b5a9750-0b64-4c5a-8145-ae0c3feac354)

## 2.3 代码
```python
# 获取灰度图像
img = cv2.imread("lenna.png", 1)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 灰度图像直方图均衡化
dst = cv2.equalizeHist(gray)

# 直方图
hist = cv2.calcHist([dst],[0],None,[256],[0,256])

plt.figure()
plt.hist(dst.ravel(), 256)
plt.show()
```

# 3.Sobel边缘检测
## 3.1 定义

Sobel更强调和边缘相邻的像素点对边缘的影响

![image](https://github.com/Jadeuniq/badou-ai-special-2024/assets/144694703/30c4f173-8715-44ef-8e95-d5ec011ef964)

## 3.2 代码
```python
img = cv2.imread("lenna.png", 0)

x = cv2.Sobel(img, cv2.CV_16S, 1, 0)
y = cv2.Sobel(img, cv2.CV_16S, 0, 1)

dst = cv2.addWeighted(absX, 0.5, absY, 0.5, 0)
 
cv2.imshow("absX", absX)
cv2.imshow("absY", absY)
 
cv2.imshow("Result", dst)

```
